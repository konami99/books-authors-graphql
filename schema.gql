# -----------------------------------------------
# !!! THIS FILE WAS GENERATED BY TYPE-GRAPHQL !!!
# !!!   DO NOT MODIFY THIS FILE BY YOURSELF   !!!
# -----------------------------------------------

type AffectedRowsOutput {
  count: Int!
}

type AggregateAuthor {
  _avg: AuthorAvgAggregate
  _count: AuthorCountAggregate
  _max: AuthorMaxAggregate
  _min: AuthorMinAggregate
  _sum: AuthorSumAggregate
}

type AggregateBankAccount {
  _avg: BankAccountAvgAggregate
  _count: BankAccountCountAggregate
  _max: BankAccountMaxAggregate
  _min: BankAccountMinAggregate
  _sum: BankAccountSumAggregate
}

type AggregateBook {
  _avg: BookAvgAggregate
  _count: BookCountAggregate
  _max: BookMaxAggregate
  _min: BookMinAggregate
  _sum: BookSumAggregate
}

type AggregateBooksOnAuthors {
  _avg: BooksOnAuthorsAvgAggregate
  _count: BooksOnAuthorsCountAggregate
  _max: BooksOnAuthorsMaxAggregate
  _min: BooksOnAuthorsMinAggregate
  _sum: BooksOnAuthorsSumAggregate
}

type AggregatePseudonym {
  _avg: PseudonymAvgAggregate
  _count: PseudonymCountAggregate
  _max: PseudonymMaxAggregate
  _min: PseudonymMinAggregate
  _sum: PseudonymSumAggregate
}

type Author {
  _count: AuthorCount
  bankAccounts(cursor: BankAccountWhereUniqueInput, distinct: [BankAccountScalarFieldEnum!], orderBy: [BankAccountOrderByWithRelationInput!], skip: Int, take: Int, where: BankAccountWhereInput): [BankAccount!]!
  books(cursor: BooksOnAuthorsWhereUniqueInput, distinct: [BooksOnAuthorsScalarFieldEnum!], orderBy: [BooksOnAuthorsOrderByWithRelationInput!], skip: Int, take: Int, where: BooksOnAuthorsWhereInput): [BooksOnAuthors!]!
  createdAt: DateTime!
  gender: String!
  id: Int!

  """@Validator.MinLength(3)"""
  name: String!
  pseudonym(where: PseudonymWhereInput): Pseudonym
  updatedAt: DateTime!
}

type AuthorAvgAggregate {
  id: Float
}

input AuthorAvgOrderByAggregateInput {
  id: SortOrder
}

type AuthorCount {
  bankAccounts(where: BankAccountWhereInput): Int!
  books(where: BooksOnAuthorsWhereInput): Int!
}

type AuthorCountAggregate {
  _all: Int!
  createdAt: Int!
  gender: Int!
  id: Int!
  name: Int!
  updatedAt: Int!
}

input AuthorCountOrderByAggregateInput {
  createdAt: SortOrder
  gender: SortOrder
  id: SortOrder
  name: SortOrder
  updatedAt: SortOrder
}

input AuthorCreateInput {
  bankAccounts: BankAccountCreateNestedManyWithoutAuthorInput
  books: BooksOnAuthorsCreateNestedManyWithoutAuthorInput
  createdAt: DateTime
  gender: String!
  name: String!
  pseudonym: PseudonymCreateNestedOneWithoutAuthorInput
  updatedAt: DateTime
}

input AuthorCreateManyInput {
  createdAt: DateTime
  gender: String!
  id: Int
  name: String!
  updatedAt: DateTime
}

input AuthorCreateNestedOneWithoutBankAccountsInput {
  connect: AuthorWhereUniqueInput
  connectOrCreate: AuthorCreateOrConnectWithoutBankAccountsInput
  create: AuthorCreateWithoutBankAccountsInput
}

input AuthorCreateNestedOneWithoutBooksInput {
  connect: AuthorWhereUniqueInput
  connectOrCreate: AuthorCreateOrConnectWithoutBooksInput
  create: AuthorCreateWithoutBooksInput
}

input AuthorCreateNestedOneWithoutPseudonymInput {
  connect: AuthorWhereUniqueInput
  connectOrCreate: AuthorCreateOrConnectWithoutPseudonymInput
  create: AuthorCreateWithoutPseudonymInput
}

input AuthorCreateOrConnectWithoutBankAccountsInput {
  create: AuthorCreateWithoutBankAccountsInput!
  where: AuthorWhereUniqueInput!
}

input AuthorCreateOrConnectWithoutBooksInput {
  create: AuthorCreateWithoutBooksInput!
  where: AuthorWhereUniqueInput!
}

input AuthorCreateOrConnectWithoutPseudonymInput {
  create: AuthorCreateWithoutPseudonymInput!
  where: AuthorWhereUniqueInput!
}

input AuthorCreateWithoutBankAccountsInput {
  books: BooksOnAuthorsCreateNestedManyWithoutAuthorInput
  createdAt: DateTime
  gender: String!
  name: String!
  pseudonym: PseudonymCreateNestedOneWithoutAuthorInput
  updatedAt: DateTime
}

input AuthorCreateWithoutBooksInput {
  bankAccounts: BankAccountCreateNestedManyWithoutAuthorInput
  createdAt: DateTime
  gender: String!
  name: String!
  pseudonym: PseudonymCreateNestedOneWithoutAuthorInput
  updatedAt: DateTime
}

input AuthorCreateWithoutPseudonymInput {
  bankAccounts: BankAccountCreateNestedManyWithoutAuthorInput
  books: BooksOnAuthorsCreateNestedManyWithoutAuthorInput
  createdAt: DateTime
  gender: String!
  name: String!
  updatedAt: DateTime
}

type AuthorGroupBy {
  _avg: AuthorAvgAggregate
  _count: AuthorCountAggregate
  _max: AuthorMaxAggregate
  _min: AuthorMinAggregate
  _sum: AuthorSumAggregate
  createdAt: DateTime!
  gender: String!
  id: Int!
  name: String!
  updatedAt: DateTime!
}

type AuthorMaxAggregate {
  createdAt: DateTime
  gender: String
  id: Int
  name: String
  updatedAt: DateTime
}

input AuthorMaxOrderByAggregateInput {
  createdAt: SortOrder
  gender: SortOrder
  id: SortOrder
  name: SortOrder
  updatedAt: SortOrder
}

type AuthorMinAggregate {
  createdAt: DateTime
  gender: String
  id: Int
  name: String
  updatedAt: DateTime
}

input AuthorMinOrderByAggregateInput {
  createdAt: SortOrder
  gender: SortOrder
  id: SortOrder
  name: SortOrder
  updatedAt: SortOrder
}

input AuthorOrderByWithAggregationInput {
  _avg: AuthorAvgOrderByAggregateInput
  _count: AuthorCountOrderByAggregateInput
  _max: AuthorMaxOrderByAggregateInput
  _min: AuthorMinOrderByAggregateInput
  _sum: AuthorSumOrderByAggregateInput
  createdAt: SortOrder
  gender: SortOrder
  id: SortOrder
  name: SortOrder
  updatedAt: SortOrder
}

input AuthorOrderByWithRelationInput {
  bankAccounts: BankAccountOrderByRelationAggregateInput
  books: BooksOnAuthorsOrderByRelationAggregateInput
  createdAt: SortOrder
  gender: SortOrder
  id: SortOrder
  name: SortOrder
  pseudonym: PseudonymOrderByWithRelationInput
  updatedAt: SortOrder
}

input AuthorRelationFilter {
  is: AuthorWhereInput
  isNot: AuthorWhereInput
}

enum AuthorScalarFieldEnum {
  createdAt
  gender
  id
  name
  updatedAt
}

input AuthorScalarWhereWithAggregatesInput {
  AND: [AuthorScalarWhereWithAggregatesInput!]
  NOT: [AuthorScalarWhereWithAggregatesInput!]
  OR: [AuthorScalarWhereWithAggregatesInput!]
  createdAt: DateTimeWithAggregatesFilter
  gender: StringWithAggregatesFilter
  id: IntWithAggregatesFilter
  name: StringWithAggregatesFilter
  updatedAt: DateTimeWithAggregatesFilter
}

type AuthorSumAggregate {
  id: Int
}

input AuthorSumOrderByAggregateInput {
  id: SortOrder
}

input AuthorUpdateInput {
  bankAccounts: BankAccountUpdateManyWithoutAuthorNestedInput
  books: BooksOnAuthorsUpdateManyWithoutAuthorNestedInput
  createdAt: DateTimeFieldUpdateOperationsInput
  gender: StringFieldUpdateOperationsInput
  name: StringFieldUpdateOperationsInput
  pseudonym: PseudonymUpdateOneWithoutAuthorNestedInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input AuthorUpdateManyMutationInput {
  createdAt: DateTimeFieldUpdateOperationsInput
  gender: StringFieldUpdateOperationsInput
  name: StringFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input AuthorUpdateOneRequiredWithoutBankAccountsNestedInput {
  connect: AuthorWhereUniqueInput
  connectOrCreate: AuthorCreateOrConnectWithoutBankAccountsInput
  create: AuthorCreateWithoutBankAccountsInput
  update: AuthorUpdateToOneWithWhereWithoutBankAccountsInput
  upsert: AuthorUpsertWithoutBankAccountsInput
}

input AuthorUpdateOneRequiredWithoutBooksNestedInput {
  connect: AuthorWhereUniqueInput
  connectOrCreate: AuthorCreateOrConnectWithoutBooksInput
  create: AuthorCreateWithoutBooksInput
  update: AuthorUpdateToOneWithWhereWithoutBooksInput
  upsert: AuthorUpsertWithoutBooksInput
}

input AuthorUpdateOneRequiredWithoutPseudonymNestedInput {
  connect: AuthorWhereUniqueInput
  connectOrCreate: AuthorCreateOrConnectWithoutPseudonymInput
  create: AuthorCreateWithoutPseudonymInput
  update: AuthorUpdateToOneWithWhereWithoutPseudonymInput
  upsert: AuthorUpsertWithoutPseudonymInput
}

input AuthorUpdateToOneWithWhereWithoutBankAccountsInput {
  data: AuthorUpdateWithoutBankAccountsInput!
  where: AuthorWhereInput
}

input AuthorUpdateToOneWithWhereWithoutBooksInput {
  data: AuthorUpdateWithoutBooksInput!
  where: AuthorWhereInput
}

input AuthorUpdateToOneWithWhereWithoutPseudonymInput {
  data: AuthorUpdateWithoutPseudonymInput!
  where: AuthorWhereInput
}

input AuthorUpdateWithoutBankAccountsInput {
  books: BooksOnAuthorsUpdateManyWithoutAuthorNestedInput
  createdAt: DateTimeFieldUpdateOperationsInput
  gender: StringFieldUpdateOperationsInput
  name: StringFieldUpdateOperationsInput
  pseudonym: PseudonymUpdateOneWithoutAuthorNestedInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input AuthorUpdateWithoutBooksInput {
  bankAccounts: BankAccountUpdateManyWithoutAuthorNestedInput
  createdAt: DateTimeFieldUpdateOperationsInput
  gender: StringFieldUpdateOperationsInput
  name: StringFieldUpdateOperationsInput
  pseudonym: PseudonymUpdateOneWithoutAuthorNestedInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input AuthorUpdateWithoutPseudonymInput {
  bankAccounts: BankAccountUpdateManyWithoutAuthorNestedInput
  books: BooksOnAuthorsUpdateManyWithoutAuthorNestedInput
  createdAt: DateTimeFieldUpdateOperationsInput
  gender: StringFieldUpdateOperationsInput
  name: StringFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input AuthorUpsertWithoutBankAccountsInput {
  create: AuthorCreateWithoutBankAccountsInput!
  update: AuthorUpdateWithoutBankAccountsInput!
  where: AuthorWhereInput
}

input AuthorUpsertWithoutBooksInput {
  create: AuthorCreateWithoutBooksInput!
  update: AuthorUpdateWithoutBooksInput!
  where: AuthorWhereInput
}

input AuthorUpsertWithoutPseudonymInput {
  create: AuthorCreateWithoutPseudonymInput!
  update: AuthorUpdateWithoutPseudonymInput!
  where: AuthorWhereInput
}

input AuthorWhereInput {
  AND: [AuthorWhereInput!]
  NOT: [AuthorWhereInput!]
  OR: [AuthorWhereInput!]
  bankAccounts: BankAccountListRelationFilter
  books: BooksOnAuthorsListRelationFilter
  createdAt: DateTimeFilter
  gender: StringFilter
  id: IntFilter
  name: StringFilter
  pseudonym: PseudonymNullableRelationFilter
  updatedAt: DateTimeFilter
}

input AuthorWhereUniqueInput {
  AND: [AuthorWhereInput!]
  NOT: [AuthorWhereInput!]
  OR: [AuthorWhereInput!]
  bankAccounts: BankAccountListRelationFilter
  books: BooksOnAuthorsListRelationFilter
  createdAt: DateTimeFilter
  gender: StringFilter
  id: Int
  name: StringFilter
  pseudonym: PseudonymNullableRelationFilter
  updatedAt: DateTimeFilter
}

type BankAccount {
  accountNumber: String!
  author: Author!
  authorId: Int!
  createdAt: DateTime!
  id: Int!
  updatedAt: DateTime!
}

type BankAccountAvgAggregate {
  authorId: Float
  id: Float
}

input BankAccountAvgOrderByAggregateInput {
  authorId: SortOrder
  id: SortOrder
}

type BankAccountCountAggregate {
  _all: Int!
  accountNumber: Int!
  authorId: Int!
  createdAt: Int!
  id: Int!
  updatedAt: Int!
}

input BankAccountCountOrderByAggregateInput {
  accountNumber: SortOrder
  authorId: SortOrder
  createdAt: SortOrder
  id: SortOrder
  updatedAt: SortOrder
}

input BankAccountCreateInput {
  accountNumber: String!
  author: AuthorCreateNestedOneWithoutBankAccountsInput!
  createdAt: DateTime
  updatedAt: DateTime
}

input BankAccountCreateManyAuthorInput {
  accountNumber: String!
  createdAt: DateTime
  id: Int
  updatedAt: DateTime
}

input BankAccountCreateManyAuthorInputEnvelope {
  data: [BankAccountCreateManyAuthorInput!]!
  skipDuplicates: Boolean
}

input BankAccountCreateManyInput {
  accountNumber: String!
  authorId: Int!
  createdAt: DateTime
  id: Int
  updatedAt: DateTime
}

input BankAccountCreateNestedManyWithoutAuthorInput {
  connect: [BankAccountWhereUniqueInput!]
  connectOrCreate: [BankAccountCreateOrConnectWithoutAuthorInput!]
  create: [BankAccountCreateWithoutAuthorInput!]
  createMany: BankAccountCreateManyAuthorInputEnvelope
}

input BankAccountCreateOrConnectWithoutAuthorInput {
  create: BankAccountCreateWithoutAuthorInput!
  where: BankAccountWhereUniqueInput!
}

input BankAccountCreateWithoutAuthorInput {
  accountNumber: String!
  createdAt: DateTime
  updatedAt: DateTime
}

type BankAccountGroupBy {
  _avg: BankAccountAvgAggregate
  _count: BankAccountCountAggregate
  _max: BankAccountMaxAggregate
  _min: BankAccountMinAggregate
  _sum: BankAccountSumAggregate
  accountNumber: String!
  authorId: Int!
  createdAt: DateTime!
  id: Int!
  updatedAt: DateTime!
}

input BankAccountListRelationFilter {
  every: BankAccountWhereInput
  none: BankAccountWhereInput
  some: BankAccountWhereInput
}

type BankAccountMaxAggregate {
  accountNumber: String
  authorId: Int
  createdAt: DateTime
  id: Int
  updatedAt: DateTime
}

input BankAccountMaxOrderByAggregateInput {
  accountNumber: SortOrder
  authorId: SortOrder
  createdAt: SortOrder
  id: SortOrder
  updatedAt: SortOrder
}

type BankAccountMinAggregate {
  accountNumber: String
  authorId: Int
  createdAt: DateTime
  id: Int
  updatedAt: DateTime
}

input BankAccountMinOrderByAggregateInput {
  accountNumber: SortOrder
  authorId: SortOrder
  createdAt: SortOrder
  id: SortOrder
  updatedAt: SortOrder
}

input BankAccountOrderByRelationAggregateInput {
  _count: SortOrder
}

input BankAccountOrderByWithAggregationInput {
  _avg: BankAccountAvgOrderByAggregateInput
  _count: BankAccountCountOrderByAggregateInput
  _max: BankAccountMaxOrderByAggregateInput
  _min: BankAccountMinOrderByAggregateInput
  _sum: BankAccountSumOrderByAggregateInput
  accountNumber: SortOrder
  authorId: SortOrder
  createdAt: SortOrder
  id: SortOrder
  updatedAt: SortOrder
}

input BankAccountOrderByWithRelationInput {
  accountNumber: SortOrder
  author: AuthorOrderByWithRelationInput
  authorId: SortOrder
  createdAt: SortOrder
  id: SortOrder
  updatedAt: SortOrder
}

enum BankAccountScalarFieldEnum {
  accountNumber
  authorId
  createdAt
  id
  updatedAt
}

input BankAccountScalarWhereInput {
  AND: [BankAccountScalarWhereInput!]
  NOT: [BankAccountScalarWhereInput!]
  OR: [BankAccountScalarWhereInput!]
  accountNumber: StringFilter
  authorId: IntFilter
  createdAt: DateTimeFilter
  id: IntFilter
  updatedAt: DateTimeFilter
}

input BankAccountScalarWhereWithAggregatesInput {
  AND: [BankAccountScalarWhereWithAggregatesInput!]
  NOT: [BankAccountScalarWhereWithAggregatesInput!]
  OR: [BankAccountScalarWhereWithAggregatesInput!]
  accountNumber: StringWithAggregatesFilter
  authorId: IntWithAggregatesFilter
  createdAt: DateTimeWithAggregatesFilter
  id: IntWithAggregatesFilter
  updatedAt: DateTimeWithAggregatesFilter
}

type BankAccountSumAggregate {
  authorId: Int
  id: Int
}

input BankAccountSumOrderByAggregateInput {
  authorId: SortOrder
  id: SortOrder
}

input BankAccountUpdateInput {
  accountNumber: StringFieldUpdateOperationsInput
  author: AuthorUpdateOneRequiredWithoutBankAccountsNestedInput
  createdAt: DateTimeFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input BankAccountUpdateManyMutationInput {
  accountNumber: StringFieldUpdateOperationsInput
  createdAt: DateTimeFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input BankAccountUpdateManyWithWhereWithoutAuthorInput {
  data: BankAccountUpdateManyMutationInput!
  where: BankAccountScalarWhereInput!
}

input BankAccountUpdateManyWithoutAuthorNestedInput {
  connect: [BankAccountWhereUniqueInput!]
  connectOrCreate: [BankAccountCreateOrConnectWithoutAuthorInput!]
  create: [BankAccountCreateWithoutAuthorInput!]
  createMany: BankAccountCreateManyAuthorInputEnvelope
  delete: [BankAccountWhereUniqueInput!]
  deleteMany: [BankAccountScalarWhereInput!]
  disconnect: [BankAccountWhereUniqueInput!]
  set: [BankAccountWhereUniqueInput!]
  update: [BankAccountUpdateWithWhereUniqueWithoutAuthorInput!]
  updateMany: [BankAccountUpdateManyWithWhereWithoutAuthorInput!]
  upsert: [BankAccountUpsertWithWhereUniqueWithoutAuthorInput!]
}

input BankAccountUpdateWithWhereUniqueWithoutAuthorInput {
  data: BankAccountUpdateWithoutAuthorInput!
  where: BankAccountWhereUniqueInput!
}

input BankAccountUpdateWithoutAuthorInput {
  accountNumber: StringFieldUpdateOperationsInput
  createdAt: DateTimeFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input BankAccountUpsertWithWhereUniqueWithoutAuthorInput {
  create: BankAccountCreateWithoutAuthorInput!
  update: BankAccountUpdateWithoutAuthorInput!
  where: BankAccountWhereUniqueInput!
}

input BankAccountWhereInput {
  AND: [BankAccountWhereInput!]
  NOT: [BankAccountWhereInput!]
  OR: [BankAccountWhereInput!]
  accountNumber: StringFilter
  author: AuthorRelationFilter
  authorId: IntFilter
  createdAt: DateTimeFilter
  id: IntFilter
  updatedAt: DateTimeFilter
}

input BankAccountWhereUniqueInput {
  AND: [BankAccountWhereInput!]
  NOT: [BankAccountWhereInput!]
  OR: [BankAccountWhereInput!]
  accountNumber: StringFilter
  author: AuthorRelationFilter
  authorId: IntFilter
  createdAt: DateTimeFilter
  id: Int
  updatedAt: DateTimeFilter
}

type Book {
  _count: BookCount
  authors(cursor: BooksOnAuthorsWhereUniqueInput, distinct: [BooksOnAuthorsScalarFieldEnum!], orderBy: [BooksOnAuthorsOrderByWithRelationInput!], skip: Int, take: Int, where: BooksOnAuthorsWhereInput): [BooksOnAuthors!]!
  createdAt: DateTime!
  id: Int!
  title: String!
  updatedAt: DateTime!
}

type BookAvgAggregate {
  id: Float
}

input BookAvgOrderByAggregateInput {
  id: SortOrder
}

type BookCount {
  authors(where: BooksOnAuthorsWhereInput): Int!
}

type BookCountAggregate {
  _all: Int!
  createdAt: Int!
  id: Int!
  title: Int!
  updatedAt: Int!
}

input BookCountOrderByAggregateInput {
  createdAt: SortOrder
  id: SortOrder
  title: SortOrder
  updatedAt: SortOrder
}

input BookCreateInput {
  authors: BooksOnAuthorsCreateNestedManyWithoutBookInput
  createdAt: DateTime
  title: String!
  updatedAt: DateTime
}

input BookCreateManyInput {
  createdAt: DateTime
  id: Int
  title: String!
  updatedAt: DateTime
}

input BookCreateNestedOneWithoutAuthorsInput {
  connect: BookWhereUniqueInput
  connectOrCreate: BookCreateOrConnectWithoutAuthorsInput
  create: BookCreateWithoutAuthorsInput
}

input BookCreateOrConnectWithoutAuthorsInput {
  create: BookCreateWithoutAuthorsInput!
  where: BookWhereUniqueInput!
}

input BookCreateWithoutAuthorsInput {
  createdAt: DateTime
  title: String!
  updatedAt: DateTime
}

type BookGroupBy {
  _avg: BookAvgAggregate
  _count: BookCountAggregate
  _max: BookMaxAggregate
  _min: BookMinAggregate
  _sum: BookSumAggregate
  createdAt: DateTime!
  id: Int!
  title: String!
  updatedAt: DateTime!
}

type BookMaxAggregate {
  createdAt: DateTime
  id: Int
  title: String
  updatedAt: DateTime
}

input BookMaxOrderByAggregateInput {
  createdAt: SortOrder
  id: SortOrder
  title: SortOrder
  updatedAt: SortOrder
}

type BookMinAggregate {
  createdAt: DateTime
  id: Int
  title: String
  updatedAt: DateTime
}

input BookMinOrderByAggregateInput {
  createdAt: SortOrder
  id: SortOrder
  title: SortOrder
  updatedAt: SortOrder
}

input BookOrderByWithAggregationInput {
  _avg: BookAvgOrderByAggregateInput
  _count: BookCountOrderByAggregateInput
  _max: BookMaxOrderByAggregateInput
  _min: BookMinOrderByAggregateInput
  _sum: BookSumOrderByAggregateInput
  createdAt: SortOrder
  id: SortOrder
  title: SortOrder
  updatedAt: SortOrder
}

input BookOrderByWithRelationInput {
  authors: BooksOnAuthorsOrderByRelationAggregateInput
  createdAt: SortOrder
  id: SortOrder
  title: SortOrder
  updatedAt: SortOrder
}

input BookRelationFilter {
  is: BookWhereInput
  isNot: BookWhereInput
}

enum BookScalarFieldEnum {
  createdAt
  id
  title
  updatedAt
}

input BookScalarWhereWithAggregatesInput {
  AND: [BookScalarWhereWithAggregatesInput!]
  NOT: [BookScalarWhereWithAggregatesInput!]
  OR: [BookScalarWhereWithAggregatesInput!]
  createdAt: DateTimeWithAggregatesFilter
  id: IntWithAggregatesFilter
  title: StringWithAggregatesFilter
  updatedAt: DateTimeWithAggregatesFilter
}

type BookSumAggregate {
  id: Int
}

input BookSumOrderByAggregateInput {
  id: SortOrder
}

input BookUpdateInput {
  authors: BooksOnAuthorsUpdateManyWithoutBookNestedInput
  createdAt: DateTimeFieldUpdateOperationsInput
  title: StringFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input BookUpdateManyMutationInput {
  createdAt: DateTimeFieldUpdateOperationsInput
  title: StringFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input BookUpdateOneRequiredWithoutAuthorsNestedInput {
  connect: BookWhereUniqueInput
  connectOrCreate: BookCreateOrConnectWithoutAuthorsInput
  create: BookCreateWithoutAuthorsInput
  update: BookUpdateToOneWithWhereWithoutAuthorsInput
  upsert: BookUpsertWithoutAuthorsInput
}

input BookUpdateToOneWithWhereWithoutAuthorsInput {
  data: BookUpdateWithoutAuthorsInput!
  where: BookWhereInput
}

input BookUpdateWithoutAuthorsInput {
  createdAt: DateTimeFieldUpdateOperationsInput
  title: StringFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input BookUpsertWithoutAuthorsInput {
  create: BookCreateWithoutAuthorsInput!
  update: BookUpdateWithoutAuthorsInput!
  where: BookWhereInput
}

input BookWhereInput {
  AND: [BookWhereInput!]
  NOT: [BookWhereInput!]
  OR: [BookWhereInput!]
  authors: BooksOnAuthorsListRelationFilter
  createdAt: DateTimeFilter
  id: IntFilter
  title: StringFilter
  updatedAt: DateTimeFilter
}

input BookWhereUniqueInput {
  AND: [BookWhereInput!]
  NOT: [BookWhereInput!]
  OR: [BookWhereInput!]
  authors: BooksOnAuthorsListRelationFilter
  createdAt: DateTimeFilter
  id: Int
  title: StringFilter
  updatedAt: DateTimeFilter
}

type BooksOnAuthors {
  author: Author!
  authorId: Int!
  book: Book!
  bookId: Int!
  createdAt: DateTime!
}

type BooksOnAuthorsAvgAggregate {
  authorId: Float
  bookId: Float
}

input BooksOnAuthorsAvgOrderByAggregateInput {
  authorId: SortOrder
  bookId: SortOrder
}

input BooksOnAuthorsBookIdAuthorIdCompoundUniqueInput {
  authorId: Int!
  bookId: Int!
}

type BooksOnAuthorsCountAggregate {
  _all: Int!
  authorId: Int!
  bookId: Int!
  createdAt: Int!
}

input BooksOnAuthorsCountOrderByAggregateInput {
  authorId: SortOrder
  bookId: SortOrder
  createdAt: SortOrder
}

input BooksOnAuthorsCreateInput {
  author: AuthorCreateNestedOneWithoutBooksInput!
  book: BookCreateNestedOneWithoutAuthorsInput!
  createdAt: DateTime
}

input BooksOnAuthorsCreateManyAuthorInput {
  bookId: Int!
  createdAt: DateTime
}

input BooksOnAuthorsCreateManyAuthorInputEnvelope {
  data: [BooksOnAuthorsCreateManyAuthorInput!]!
  skipDuplicates: Boolean
}

input BooksOnAuthorsCreateManyBookInput {
  authorId: Int!
  createdAt: DateTime
}

input BooksOnAuthorsCreateManyBookInputEnvelope {
  data: [BooksOnAuthorsCreateManyBookInput!]!
  skipDuplicates: Boolean
}

input BooksOnAuthorsCreateManyInput {
  authorId: Int!
  bookId: Int!
  createdAt: DateTime
}

input BooksOnAuthorsCreateNestedManyWithoutAuthorInput {
  connect: [BooksOnAuthorsWhereUniqueInput!]
  connectOrCreate: [BooksOnAuthorsCreateOrConnectWithoutAuthorInput!]
  create: [BooksOnAuthorsCreateWithoutAuthorInput!]
  createMany: BooksOnAuthorsCreateManyAuthorInputEnvelope
}

input BooksOnAuthorsCreateNestedManyWithoutBookInput {
  connect: [BooksOnAuthorsWhereUniqueInput!]
  connectOrCreate: [BooksOnAuthorsCreateOrConnectWithoutBookInput!]
  create: [BooksOnAuthorsCreateWithoutBookInput!]
  createMany: BooksOnAuthorsCreateManyBookInputEnvelope
}

input BooksOnAuthorsCreateOrConnectWithoutAuthorInput {
  create: BooksOnAuthorsCreateWithoutAuthorInput!
  where: BooksOnAuthorsWhereUniqueInput!
}

input BooksOnAuthorsCreateOrConnectWithoutBookInput {
  create: BooksOnAuthorsCreateWithoutBookInput!
  where: BooksOnAuthorsWhereUniqueInput!
}

input BooksOnAuthorsCreateWithoutAuthorInput {
  book: BookCreateNestedOneWithoutAuthorsInput!
  createdAt: DateTime
}

input BooksOnAuthorsCreateWithoutBookInput {
  author: AuthorCreateNestedOneWithoutBooksInput!
  createdAt: DateTime
}

type BooksOnAuthorsGroupBy {
  _avg: BooksOnAuthorsAvgAggregate
  _count: BooksOnAuthorsCountAggregate
  _max: BooksOnAuthorsMaxAggregate
  _min: BooksOnAuthorsMinAggregate
  _sum: BooksOnAuthorsSumAggregate
  authorId: Int!
  bookId: Int!
  createdAt: DateTime!
}

input BooksOnAuthorsListRelationFilter {
  every: BooksOnAuthorsWhereInput
  none: BooksOnAuthorsWhereInput
  some: BooksOnAuthorsWhereInput
}

type BooksOnAuthorsMaxAggregate {
  authorId: Int
  bookId: Int
  createdAt: DateTime
}

input BooksOnAuthorsMaxOrderByAggregateInput {
  authorId: SortOrder
  bookId: SortOrder
  createdAt: SortOrder
}

type BooksOnAuthorsMinAggregate {
  authorId: Int
  bookId: Int
  createdAt: DateTime
}

input BooksOnAuthorsMinOrderByAggregateInput {
  authorId: SortOrder
  bookId: SortOrder
  createdAt: SortOrder
}

input BooksOnAuthorsOrderByRelationAggregateInput {
  _count: SortOrder
}

input BooksOnAuthorsOrderByWithAggregationInput {
  _avg: BooksOnAuthorsAvgOrderByAggregateInput
  _count: BooksOnAuthorsCountOrderByAggregateInput
  _max: BooksOnAuthorsMaxOrderByAggregateInput
  _min: BooksOnAuthorsMinOrderByAggregateInput
  _sum: BooksOnAuthorsSumOrderByAggregateInput
  authorId: SortOrder
  bookId: SortOrder
  createdAt: SortOrder
}

input BooksOnAuthorsOrderByWithRelationInput {
  author: AuthorOrderByWithRelationInput
  authorId: SortOrder
  book: BookOrderByWithRelationInput
  bookId: SortOrder
  createdAt: SortOrder
}

enum BooksOnAuthorsScalarFieldEnum {
  authorId
  bookId
  createdAt
}

input BooksOnAuthorsScalarWhereInput {
  AND: [BooksOnAuthorsScalarWhereInput!]
  NOT: [BooksOnAuthorsScalarWhereInput!]
  OR: [BooksOnAuthorsScalarWhereInput!]
  authorId: IntFilter
  bookId: IntFilter
  createdAt: DateTimeFilter
}

input BooksOnAuthorsScalarWhereWithAggregatesInput {
  AND: [BooksOnAuthorsScalarWhereWithAggregatesInput!]
  NOT: [BooksOnAuthorsScalarWhereWithAggregatesInput!]
  OR: [BooksOnAuthorsScalarWhereWithAggregatesInput!]
  authorId: IntWithAggregatesFilter
  bookId: IntWithAggregatesFilter
  createdAt: DateTimeWithAggregatesFilter
}

type BooksOnAuthorsSumAggregate {
  authorId: Int
  bookId: Int
}

input BooksOnAuthorsSumOrderByAggregateInput {
  authorId: SortOrder
  bookId: SortOrder
}

input BooksOnAuthorsUpdateInput {
  author: AuthorUpdateOneRequiredWithoutBooksNestedInput
  book: BookUpdateOneRequiredWithoutAuthorsNestedInput
  createdAt: DateTimeFieldUpdateOperationsInput
}

input BooksOnAuthorsUpdateManyMutationInput {
  createdAt: DateTimeFieldUpdateOperationsInput
}

input BooksOnAuthorsUpdateManyWithWhereWithoutAuthorInput {
  data: BooksOnAuthorsUpdateManyMutationInput!
  where: BooksOnAuthorsScalarWhereInput!
}

input BooksOnAuthorsUpdateManyWithWhereWithoutBookInput {
  data: BooksOnAuthorsUpdateManyMutationInput!
  where: BooksOnAuthorsScalarWhereInput!
}

input BooksOnAuthorsUpdateManyWithoutAuthorNestedInput {
  connect: [BooksOnAuthorsWhereUniqueInput!]
  connectOrCreate: [BooksOnAuthorsCreateOrConnectWithoutAuthorInput!]
  create: [BooksOnAuthorsCreateWithoutAuthorInput!]
  createMany: BooksOnAuthorsCreateManyAuthorInputEnvelope
  delete: [BooksOnAuthorsWhereUniqueInput!]
  deleteMany: [BooksOnAuthorsScalarWhereInput!]
  disconnect: [BooksOnAuthorsWhereUniqueInput!]
  set: [BooksOnAuthorsWhereUniqueInput!]
  update: [BooksOnAuthorsUpdateWithWhereUniqueWithoutAuthorInput!]
  updateMany: [BooksOnAuthorsUpdateManyWithWhereWithoutAuthorInput!]
  upsert: [BooksOnAuthorsUpsertWithWhereUniqueWithoutAuthorInput!]
}

input BooksOnAuthorsUpdateManyWithoutBookNestedInput {
  connect: [BooksOnAuthorsWhereUniqueInput!]
  connectOrCreate: [BooksOnAuthorsCreateOrConnectWithoutBookInput!]
  create: [BooksOnAuthorsCreateWithoutBookInput!]
  createMany: BooksOnAuthorsCreateManyBookInputEnvelope
  delete: [BooksOnAuthorsWhereUniqueInput!]
  deleteMany: [BooksOnAuthorsScalarWhereInput!]
  disconnect: [BooksOnAuthorsWhereUniqueInput!]
  set: [BooksOnAuthorsWhereUniqueInput!]
  update: [BooksOnAuthorsUpdateWithWhereUniqueWithoutBookInput!]
  updateMany: [BooksOnAuthorsUpdateManyWithWhereWithoutBookInput!]
  upsert: [BooksOnAuthorsUpsertWithWhereUniqueWithoutBookInput!]
}

input BooksOnAuthorsUpdateWithWhereUniqueWithoutAuthorInput {
  data: BooksOnAuthorsUpdateWithoutAuthorInput!
  where: BooksOnAuthorsWhereUniqueInput!
}

input BooksOnAuthorsUpdateWithWhereUniqueWithoutBookInput {
  data: BooksOnAuthorsUpdateWithoutBookInput!
  where: BooksOnAuthorsWhereUniqueInput!
}

input BooksOnAuthorsUpdateWithoutAuthorInput {
  book: BookUpdateOneRequiredWithoutAuthorsNestedInput
  createdAt: DateTimeFieldUpdateOperationsInput
}

input BooksOnAuthorsUpdateWithoutBookInput {
  author: AuthorUpdateOneRequiredWithoutBooksNestedInput
  createdAt: DateTimeFieldUpdateOperationsInput
}

input BooksOnAuthorsUpsertWithWhereUniqueWithoutAuthorInput {
  create: BooksOnAuthorsCreateWithoutAuthorInput!
  update: BooksOnAuthorsUpdateWithoutAuthorInput!
  where: BooksOnAuthorsWhereUniqueInput!
}

input BooksOnAuthorsUpsertWithWhereUniqueWithoutBookInput {
  create: BooksOnAuthorsCreateWithoutBookInput!
  update: BooksOnAuthorsUpdateWithoutBookInput!
  where: BooksOnAuthorsWhereUniqueInput!
}

input BooksOnAuthorsWhereInput {
  AND: [BooksOnAuthorsWhereInput!]
  NOT: [BooksOnAuthorsWhereInput!]
  OR: [BooksOnAuthorsWhereInput!]
  author: AuthorRelationFilter
  authorId: IntFilter
  book: BookRelationFilter
  bookId: IntFilter
  createdAt: DateTimeFilter
}

input BooksOnAuthorsWhereUniqueInput {
  AND: [BooksOnAuthorsWhereInput!]
  NOT: [BooksOnAuthorsWhereInput!]
  OR: [BooksOnAuthorsWhereInput!]
  author: AuthorRelationFilter
  authorId: IntFilter
  book: BookRelationFilter
  bookId: IntFilter
  bookId_authorId: BooksOnAuthorsBookIdAuthorIdCompoundUniqueInput
  createdAt: DateTimeFilter
}

"""
The javascript `Date` as string. Type represents date and time as the ISO Date string.
"""
scalar DateTime

input DateTimeFieldUpdateOperationsInput {
  set: DateTime
}

input DateTimeFilter {
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime!]
  lt: DateTime
  lte: DateTime
  not: NestedDateTimeFilter
  notIn: [DateTime!]
}

input DateTimeWithAggregatesFilter {
  _count: NestedIntFilter
  _max: NestedDateTimeFilter
  _min: NestedDateTimeFilter
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime!]
  lt: DateTime
  lte: DateTime
  not: NestedDateTimeWithAggregatesFilter
  notIn: [DateTime!]
}

input IntFilter {
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntFilter
  notIn: [Int!]
}

input IntWithAggregatesFilter {
  _avg: NestedFloatFilter
  _count: NestedIntFilter
  _max: NestedIntFilter
  _min: NestedIntFilter
  _sum: NestedIntFilter
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntWithAggregatesFilter
  notIn: [Int!]
}

type Mutation {
  createManyAuthor(data: [AuthorCreateManyInput!]!, skipDuplicates: Boolean): AffectedRowsOutput!
  createManyBankAccount(data: [BankAccountCreateManyInput!]!, skipDuplicates: Boolean): AffectedRowsOutput!
  createManyBook(data: [BookCreateManyInput!]!, skipDuplicates: Boolean): AffectedRowsOutput!
  createManyBooksOnAuthors(data: [BooksOnAuthorsCreateManyInput!]!, skipDuplicates: Boolean): AffectedRowsOutput!
  createManyPseudonym(data: [PseudonymCreateManyInput!]!, skipDuplicates: Boolean): AffectedRowsOutput!
  createOneAuthor(data: AuthorCreateInput!): Author!
  createOneBankAccount(data: BankAccountCreateInput!): BankAccount!
  createOneBook(data: BookCreateInput!): Book!
  createOneBooksOnAuthors(data: BooksOnAuthorsCreateInput!): BooksOnAuthors!
  createOnePseudonym(data: PseudonymCreateInput!): Pseudonym!
  deleteManyAuthor(where: AuthorWhereInput): AffectedRowsOutput!
  deleteManyBankAccount(where: BankAccountWhereInput): AffectedRowsOutput!
  deleteManyBook(where: BookWhereInput): AffectedRowsOutput!
  deleteManyBooksOnAuthors(where: BooksOnAuthorsWhereInput): AffectedRowsOutput!
  deleteManyPseudonym(where: PseudonymWhereInput): AffectedRowsOutput!
  deleteOneAuthor(where: AuthorWhereUniqueInput!): Author
  deleteOneBankAccount(where: BankAccountWhereUniqueInput!): BankAccount
  deleteOneBook(where: BookWhereUniqueInput!): Book
  deleteOneBooksOnAuthors(where: BooksOnAuthorsWhereUniqueInput!): BooksOnAuthors
  deleteOnePseudonym(where: PseudonymWhereUniqueInput!): Pseudonym
  updateManyAuthor(data: AuthorUpdateManyMutationInput!, where: AuthorWhereInput): AffectedRowsOutput!
  updateManyBankAccount(data: BankAccountUpdateManyMutationInput!, where: BankAccountWhereInput): AffectedRowsOutput!
  updateManyBook(data: BookUpdateManyMutationInput!, where: BookWhereInput): AffectedRowsOutput!
  updateManyBooksOnAuthors(data: BooksOnAuthorsUpdateManyMutationInput!, where: BooksOnAuthorsWhereInput): AffectedRowsOutput!
  updateManyPseudonym(data: PseudonymUpdateManyMutationInput!, where: PseudonymWhereInput): AffectedRowsOutput!
  updateOneAuthor(data: AuthorUpdateInput!, where: AuthorWhereUniqueInput!): Author
  updateOneBankAccount(data: BankAccountUpdateInput!, where: BankAccountWhereUniqueInput!): BankAccount
  updateOneBook(data: BookUpdateInput!, where: BookWhereUniqueInput!): Book
  updateOneBooksOnAuthors(data: BooksOnAuthorsUpdateInput!, where: BooksOnAuthorsWhereUniqueInput!): BooksOnAuthors
  updateOnePseudonym(data: PseudonymUpdateInput!, where: PseudonymWhereUniqueInput!): Pseudonym
  upsertOneAuthor(create: AuthorCreateInput!, update: AuthorUpdateInput!, where: AuthorWhereUniqueInput!): Author!
  upsertOneBankAccount(create: BankAccountCreateInput!, update: BankAccountUpdateInput!, where: BankAccountWhereUniqueInput!): BankAccount!
  upsertOneBook(create: BookCreateInput!, update: BookUpdateInput!, where: BookWhereUniqueInput!): Book!
  upsertOneBooksOnAuthors(create: BooksOnAuthorsCreateInput!, update: BooksOnAuthorsUpdateInput!, where: BooksOnAuthorsWhereUniqueInput!): BooksOnAuthors!
  upsertOnePseudonym(create: PseudonymCreateInput!, update: PseudonymUpdateInput!, where: PseudonymWhereUniqueInput!): Pseudonym!
}

input NestedDateTimeFilter {
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime!]
  lt: DateTime
  lte: DateTime
  not: NestedDateTimeFilter
  notIn: [DateTime!]
}

input NestedDateTimeWithAggregatesFilter {
  _count: NestedIntFilter
  _max: NestedDateTimeFilter
  _min: NestedDateTimeFilter
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime!]
  lt: DateTime
  lte: DateTime
  not: NestedDateTimeWithAggregatesFilter
  notIn: [DateTime!]
}

input NestedFloatFilter {
  equals: Float
  gt: Float
  gte: Float
  in: [Float!]
  lt: Float
  lte: Float
  not: NestedFloatFilter
  notIn: [Float!]
}

input NestedIntFilter {
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntFilter
  notIn: [Int!]
}

input NestedIntWithAggregatesFilter {
  _avg: NestedFloatFilter
  _count: NestedIntFilter
  _max: NestedIntFilter
  _min: NestedIntFilter
  _sum: NestedIntFilter
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntWithAggregatesFilter
  notIn: [Int!]
}

input NestedStringFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: NestedStringFilter
  notIn: [String!]
  startsWith: String
}

input NestedStringWithAggregatesFilter {
  _count: NestedIntFilter
  _max: NestedStringFilter
  _min: NestedStringFilter
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: NestedStringWithAggregatesFilter
  notIn: [String!]
  startsWith: String
}

type Pseudonym {
  author: Author!
  authorId: Int!
  createdAt: DateTime!
  id: Int!
  name: String!
  updatedAt: DateTime!
}

type PseudonymAvgAggregate {
  authorId: Float
  id: Float
}

input PseudonymAvgOrderByAggregateInput {
  authorId: SortOrder
  id: SortOrder
}

type PseudonymCountAggregate {
  _all: Int!
  authorId: Int!
  createdAt: Int!
  id: Int!
  name: Int!
  updatedAt: Int!
}

input PseudonymCountOrderByAggregateInput {
  authorId: SortOrder
  createdAt: SortOrder
  id: SortOrder
  name: SortOrder
  updatedAt: SortOrder
}

input PseudonymCreateInput {
  author: AuthorCreateNestedOneWithoutPseudonymInput!
  createdAt: DateTime
  name: String!
  updatedAt: DateTime
}

input PseudonymCreateManyInput {
  authorId: Int!
  createdAt: DateTime
  id: Int
  name: String!
  updatedAt: DateTime
}

input PseudonymCreateNestedOneWithoutAuthorInput {
  connect: PseudonymWhereUniqueInput
  connectOrCreate: PseudonymCreateOrConnectWithoutAuthorInput
  create: PseudonymCreateWithoutAuthorInput
}

input PseudonymCreateOrConnectWithoutAuthorInput {
  create: PseudonymCreateWithoutAuthorInput!
  where: PseudonymWhereUniqueInput!
}

input PseudonymCreateWithoutAuthorInput {
  createdAt: DateTime
  name: String!
  updatedAt: DateTime
}

type PseudonymGroupBy {
  _avg: PseudonymAvgAggregate
  _count: PseudonymCountAggregate
  _max: PseudonymMaxAggregate
  _min: PseudonymMinAggregate
  _sum: PseudonymSumAggregate
  authorId: Int!
  createdAt: DateTime!
  id: Int!
  name: String!
  updatedAt: DateTime!
}

type PseudonymMaxAggregate {
  authorId: Int
  createdAt: DateTime
  id: Int
  name: String
  updatedAt: DateTime
}

input PseudonymMaxOrderByAggregateInput {
  authorId: SortOrder
  createdAt: SortOrder
  id: SortOrder
  name: SortOrder
  updatedAt: SortOrder
}

type PseudonymMinAggregate {
  authorId: Int
  createdAt: DateTime
  id: Int
  name: String
  updatedAt: DateTime
}

input PseudonymMinOrderByAggregateInput {
  authorId: SortOrder
  createdAt: SortOrder
  id: SortOrder
  name: SortOrder
  updatedAt: SortOrder
}

input PseudonymNullableRelationFilter {
  is: PseudonymWhereInput
  isNot: PseudonymWhereInput
}

input PseudonymOrderByWithAggregationInput {
  _avg: PseudonymAvgOrderByAggregateInput
  _count: PseudonymCountOrderByAggregateInput
  _max: PseudonymMaxOrderByAggregateInput
  _min: PseudonymMinOrderByAggregateInput
  _sum: PseudonymSumOrderByAggregateInput
  authorId: SortOrder
  createdAt: SortOrder
  id: SortOrder
  name: SortOrder
  updatedAt: SortOrder
}

input PseudonymOrderByWithRelationInput {
  author: AuthorOrderByWithRelationInput
  authorId: SortOrder
  createdAt: SortOrder
  id: SortOrder
  name: SortOrder
  updatedAt: SortOrder
}

enum PseudonymScalarFieldEnum {
  authorId
  createdAt
  id
  name
  updatedAt
}

input PseudonymScalarWhereWithAggregatesInput {
  AND: [PseudonymScalarWhereWithAggregatesInput!]
  NOT: [PseudonymScalarWhereWithAggregatesInput!]
  OR: [PseudonymScalarWhereWithAggregatesInput!]
  authorId: IntWithAggregatesFilter
  createdAt: DateTimeWithAggregatesFilter
  id: IntWithAggregatesFilter
  name: StringWithAggregatesFilter
  updatedAt: DateTimeWithAggregatesFilter
}

type PseudonymSumAggregate {
  authorId: Int
  id: Int
}

input PseudonymSumOrderByAggregateInput {
  authorId: SortOrder
  id: SortOrder
}

input PseudonymUpdateInput {
  author: AuthorUpdateOneRequiredWithoutPseudonymNestedInput
  createdAt: DateTimeFieldUpdateOperationsInput
  name: StringFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input PseudonymUpdateManyMutationInput {
  createdAt: DateTimeFieldUpdateOperationsInput
  name: StringFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input PseudonymUpdateOneWithoutAuthorNestedInput {
  connect: PseudonymWhereUniqueInput
  connectOrCreate: PseudonymCreateOrConnectWithoutAuthorInput
  create: PseudonymCreateWithoutAuthorInput
  delete: PseudonymWhereInput
  disconnect: PseudonymWhereInput
  update: PseudonymUpdateToOneWithWhereWithoutAuthorInput
  upsert: PseudonymUpsertWithoutAuthorInput
}

input PseudonymUpdateToOneWithWhereWithoutAuthorInput {
  data: PseudonymUpdateWithoutAuthorInput!
  where: PseudonymWhereInput
}

input PseudonymUpdateWithoutAuthorInput {
  createdAt: DateTimeFieldUpdateOperationsInput
  name: StringFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input PseudonymUpsertWithoutAuthorInput {
  create: PseudonymCreateWithoutAuthorInput!
  update: PseudonymUpdateWithoutAuthorInput!
  where: PseudonymWhereInput
}

input PseudonymWhereInput {
  AND: [PseudonymWhereInput!]
  NOT: [PseudonymWhereInput!]
  OR: [PseudonymWhereInput!]
  author: AuthorRelationFilter
  authorId: IntFilter
  createdAt: DateTimeFilter
  id: IntFilter
  name: StringFilter
  updatedAt: DateTimeFilter
}

input PseudonymWhereUniqueInput {
  AND: [PseudonymWhereInput!]
  NOT: [PseudonymWhereInput!]
  OR: [PseudonymWhereInput!]
  author: AuthorRelationFilter
  authorId: Int
  createdAt: DateTimeFilter
  id: Int
  name: StringFilter
  updatedAt: DateTimeFilter
}

type Query {
  aggregateAuthor(cursor: AuthorWhereUniqueInput, orderBy: [AuthorOrderByWithRelationInput!], skip: Int, take: Int, where: AuthorWhereInput): AggregateAuthor!
  aggregateBankAccount(cursor: BankAccountWhereUniqueInput, orderBy: [BankAccountOrderByWithRelationInput!], skip: Int, take: Int, where: BankAccountWhereInput): AggregateBankAccount!
  aggregateBook(cursor: BookWhereUniqueInput, orderBy: [BookOrderByWithRelationInput!], skip: Int, take: Int, where: BookWhereInput): AggregateBook!
  aggregateBooksOnAuthors(cursor: BooksOnAuthorsWhereUniqueInput, orderBy: [BooksOnAuthorsOrderByWithRelationInput!], skip: Int, take: Int, where: BooksOnAuthorsWhereInput): AggregateBooksOnAuthors!
  aggregatePseudonym(cursor: PseudonymWhereUniqueInput, orderBy: [PseudonymOrderByWithRelationInput!], skip: Int, take: Int, where: PseudonymWhereInput): AggregatePseudonym!
  author(where: AuthorWhereUniqueInput!): Author
  authors(cursor: AuthorWhereUniqueInput, distinct: [AuthorScalarFieldEnum!], orderBy: [AuthorOrderByWithRelationInput!], skip: Int, take: Int, where: AuthorWhereInput): [Author!]!
  bankAccount(where: BankAccountWhereUniqueInput!): BankAccount
  bankAccounts(cursor: BankAccountWhereUniqueInput, distinct: [BankAccountScalarFieldEnum!], orderBy: [BankAccountOrderByWithRelationInput!], skip: Int, take: Int, where: BankAccountWhereInput): [BankAccount!]!
  book(where: BookWhereUniqueInput!): Book
  books(cursor: BookWhereUniqueInput, distinct: [BookScalarFieldEnum!], orderBy: [BookOrderByWithRelationInput!], skip: Int, take: Int, where: BookWhereInput): [Book!]!
  findFirstAuthor(cursor: AuthorWhereUniqueInput, distinct: [AuthorScalarFieldEnum!], orderBy: [AuthorOrderByWithRelationInput!], skip: Int, take: Int, where: AuthorWhereInput): Author
  findFirstAuthorOrThrow(cursor: AuthorWhereUniqueInput, distinct: [AuthorScalarFieldEnum!], orderBy: [AuthorOrderByWithRelationInput!], skip: Int, take: Int, where: AuthorWhereInput): Author
  findFirstBankAccount(cursor: BankAccountWhereUniqueInput, distinct: [BankAccountScalarFieldEnum!], orderBy: [BankAccountOrderByWithRelationInput!], skip: Int, take: Int, where: BankAccountWhereInput): BankAccount
  findFirstBankAccountOrThrow(cursor: BankAccountWhereUniqueInput, distinct: [BankAccountScalarFieldEnum!], orderBy: [BankAccountOrderByWithRelationInput!], skip: Int, take: Int, where: BankAccountWhereInput): BankAccount
  findFirstBook(cursor: BookWhereUniqueInput, distinct: [BookScalarFieldEnum!], orderBy: [BookOrderByWithRelationInput!], skip: Int, take: Int, where: BookWhereInput): Book
  findFirstBookOrThrow(cursor: BookWhereUniqueInput, distinct: [BookScalarFieldEnum!], orderBy: [BookOrderByWithRelationInput!], skip: Int, take: Int, where: BookWhereInput): Book
  findFirstBooksOnAuthors(cursor: BooksOnAuthorsWhereUniqueInput, distinct: [BooksOnAuthorsScalarFieldEnum!], orderBy: [BooksOnAuthorsOrderByWithRelationInput!], skip: Int, take: Int, where: BooksOnAuthorsWhereInput): BooksOnAuthors
  findFirstBooksOnAuthorsOrThrow(cursor: BooksOnAuthorsWhereUniqueInput, distinct: [BooksOnAuthorsScalarFieldEnum!], orderBy: [BooksOnAuthorsOrderByWithRelationInput!], skip: Int, take: Int, where: BooksOnAuthorsWhereInput): BooksOnAuthors
  findFirstPseudonym(cursor: PseudonymWhereUniqueInput, distinct: [PseudonymScalarFieldEnum!], orderBy: [PseudonymOrderByWithRelationInput!], skip: Int, take: Int, where: PseudonymWhereInput): Pseudonym
  findFirstPseudonymOrThrow(cursor: PseudonymWhereUniqueInput, distinct: [PseudonymScalarFieldEnum!], orderBy: [PseudonymOrderByWithRelationInput!], skip: Int, take: Int, where: PseudonymWhereInput): Pseudonym
  findManyBooksOnAuthors(cursor: BooksOnAuthorsWhereUniqueInput, distinct: [BooksOnAuthorsScalarFieldEnum!], orderBy: [BooksOnAuthorsOrderByWithRelationInput!], skip: Int, take: Int, where: BooksOnAuthorsWhereInput): [BooksOnAuthors!]!
  findUniqueBooksOnAuthors(where: BooksOnAuthorsWhereUniqueInput!): BooksOnAuthors
  findUniqueBooksOnAuthorsOrThrow(where: BooksOnAuthorsWhereUniqueInput!): BooksOnAuthors
  getAuthor(where: AuthorWhereUniqueInput!): Author
  getBankAccount(where: BankAccountWhereUniqueInput!): BankAccount
  getBook(where: BookWhereUniqueInput!): Book
  getPseudonym(where: PseudonymWhereUniqueInput!): Pseudonym
  groupByAuthor(by: [AuthorScalarFieldEnum!]!, having: AuthorScalarWhereWithAggregatesInput, orderBy: [AuthorOrderByWithAggregationInput!], skip: Int, take: Int, where: AuthorWhereInput): [AuthorGroupBy!]!
  groupByBankAccount(by: [BankAccountScalarFieldEnum!]!, having: BankAccountScalarWhereWithAggregatesInput, orderBy: [BankAccountOrderByWithAggregationInput!], skip: Int, take: Int, where: BankAccountWhereInput): [BankAccountGroupBy!]!
  groupByBook(by: [BookScalarFieldEnum!]!, having: BookScalarWhereWithAggregatesInput, orderBy: [BookOrderByWithAggregationInput!], skip: Int, take: Int, where: BookWhereInput): [BookGroupBy!]!
  groupByBooksOnAuthors(by: [BooksOnAuthorsScalarFieldEnum!]!, having: BooksOnAuthorsScalarWhereWithAggregatesInput, orderBy: [BooksOnAuthorsOrderByWithAggregationInput!], skip: Int, take: Int, where: BooksOnAuthorsWhereInput): [BooksOnAuthorsGroupBy!]!
  groupByPseudonym(by: [PseudonymScalarFieldEnum!]!, having: PseudonymScalarWhereWithAggregatesInput, orderBy: [PseudonymOrderByWithAggregationInput!], skip: Int, take: Int, where: PseudonymWhereInput): [PseudonymGroupBy!]!
  pseudonym(where: PseudonymWhereUniqueInput!): Pseudonym
  pseudonyms(cursor: PseudonymWhereUniqueInput, distinct: [PseudonymScalarFieldEnum!], orderBy: [PseudonymOrderByWithRelationInput!], skip: Int, take: Int, where: PseudonymWhereInput): [Pseudonym!]!
}

enum QueryMode {
  default
  insensitive
}

enum SortOrder {
  asc
  desc
}

input StringFieldUpdateOperationsInput {
  set: String
}

input StringFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  mode: QueryMode
  not: NestedStringFilter
  notIn: [String!]
  startsWith: String
}

input StringWithAggregatesFilter {
  _count: NestedIntFilter
  _max: NestedStringFilter
  _min: NestedStringFilter
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  mode: QueryMode
  not: NestedStringWithAggregatesFilter
  notIn: [String!]
  startsWith: String
}
